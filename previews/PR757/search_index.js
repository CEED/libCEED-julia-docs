var documenterSearchIndex = {"docs":
[{"location":"Misc.html#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"","category":"section"},{"location":"Misc.html","page":"Linear Algebra","title":"Linear Algebra","text":"User Q-functions often perform small (1x1, 2x2, or 3x3) linear algebra operations (determinant, matrix-vector product, etc.) at every Q-point. For good performance, it is important to use specialized versions of these operations for the given size.","category":"page"},{"location":"Misc.html","page":"Linear Algebra","title":"Linear Algebra","text":"If the matrix or vector is given in a statically sized container (e.g. using StaticArrays.jl) then this happens automatically. However, if the matrix is not statically sized, and instead is given as, for example, a view into a larger array, then LibCEED.jl provides some convenient specialized functions.","category":"page"},{"location":"Misc.html","page":"Linear Algebra","title":"Linear Algebra","text":"In order to allow for generic code, the CeedDim struct is used for dispatch. An object D = CeedDim(dim) can be created, and passed as a second argument to functions like det to choose the specialized implementations. In this case, dim should be known as a compile-time constant, otherwise it will result in a type instability, and give poor performance.","category":"page"},{"location":"Misc.html","page":"Linear Algebra","title":"Linear Algebra","text":"For example:","category":"page"},{"location":"Misc.html","page":"Linear Algebra","title":"Linear Algebra","text":"using LibCEED, LinearAlgebra\n\ndim = 3;\nJ = rand(dim, dim);\n\ndet(J) # Slow!\ndet(J, CeedDim(dim)) # Fast!","category":"page"},{"location":"Misc.html","page":"Linear Algebra","title":"Linear Algebra","text":"CeedDim\ndet(J, ::CeedDim{1})\nsetvoigt\ngetvoigt","category":"page"},{"location":"Misc.html#LibCEED.CeedDim","page":"Linear Algebra","title":"LibCEED.CeedDim","text":"CeedDim(dim)\n\nThe singleton object of type CeedDim{dim}, used for dispatch to linear algebra operations specialized for small matrices (1, 2, or 3 dimensions).\n\n\n\n\n\n","category":"type"},{"location":"Misc.html#LinearAlgebra.det-Tuple{Any, CeedDim{1}}","page":"Linear Algebra","title":"LinearAlgebra.det","text":"det(J, ::CeedDim{dim})\n\nSpecialized determinant calculations for matrices of size 1, 2, or 3.\n\n\n\n\n\n","category":"method"},{"location":"Misc.html#LibCEED.setvoigt","page":"Linear Algebra","title":"LibCEED.setvoigt","text":"setvoigt(J::StaticArray{Tuple{D,D},T,2})\nsetvoigt(J, ::CeedDim{dim})\n\nGiven a symmetric matrix J, return a SVector that encodes J using the Voigt convention.\n\nThe size of the symmetric matrix J must be known statically, either specified using CeedDim or StaticArray.\n\n\n\n\n\n","category":"function"},{"location":"Misc.html#LibCEED.getvoigt","page":"Linear Algebra","title":"LibCEED.getvoigt","text":"getvoigt(V, ::CeedDim{dim})\n\nGiven a vector V that encodes a symmetric matrix using the Voigt convention, return the corresponding SMatrix.\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#CeedVector","page":"CeedVector","title":"CeedVector","text":"","category":"section"},{"location":"CeedVector.html","page":"CeedVector","title":"CeedVector","text":"CeedVector\nsetvalue!\nBase.setindex!(v::CeedVector, v2::CeedScalar)\nBase.setindex!(v::CeedVector, v2::AbstractArray)\nBase.Vector(v::CeedVector)\nLinearAlgebra.norm(v::CeedVector, n::NormType)\nLinearAlgebra.norm(v::CeedVector, p::Real)\n@witharray\n@witharray_read\nwitharray\nwitharray_read\nsetarray!\nsyncarray!\ntakearray!\nscale!\nLinearAlgebra.axpy!(a::CeedScalar, x::CeedVector, y::CeedVector)\npointwisemult!","category":"page"},{"location":"CeedVector.html#LibCEED.CeedVector","page":"CeedVector","title":"LibCEED.CeedVector","text":"CeedVector(c::Ceed, len::Integer)\n\nCreates a CeedVector of given length.\n\n\n\n\n\nCeedVector(c::Ceed, v2::AbstractVector; mtype=MEM_HOST, cmode=COPY_VALUES)\n\nCreates a new CeedVector using the contents of the given vector v2. By default, the contents of v2 will be copied to the new CeedVector, but this behavior can be changed by specifying a different cmode.\n\n\n\n\n\n","category":"type"},{"location":"CeedVector.html#LibCEED.setvalue!","page":"CeedVector","title":"LibCEED.setvalue!","text":"setvalue!(v::CeedVector, val::CeedScalar)\n\nSet the CeedVector to a constant value.\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#Base.setindex!-Tuple{CeedVector, Float64}","page":"CeedVector","title":"Base.setindex!","text":"setindex!(v::CeedVector, val::CeedScalar)\nv[] = val\n\nSet the CeedVector to a constant value, synonymous to setvalue!.\n\n\n\n\n\n","category":"method"},{"location":"CeedVector.html#Base.setindex!-Tuple{CeedVector, AbstractArray}","page":"CeedVector","title":"Base.setindex!","text":"setindex!(v::CeedVector, v2::AbstractArray)\nv[] = v2\n\nSets the values of CeedVector v equal to those of v2 using broadcasting.\n\n\n\n\n\n","category":"method"},{"location":"CeedVector.html#Base.Vector-Tuple{CeedVector}","page":"CeedVector","title":"Base.Vector","text":"Vector(v::CeedVector)\n\nCreate a new Vector by copying the contents of v.\n\n\n\n\n\n","category":"method"},{"location":"CeedVector.html#LinearAlgebra.norm-Tuple{CeedVector, LibCEED.C.CeedNormType}","page":"CeedVector","title":"LinearAlgebra.norm","text":"norm(v::CeedVector, ntype::NormType)\n\nReturn the norm of the given CeedVector.\n\nThe norm type can either be specified as one of NORM_1, NORM_2, NORM_MAX.\n\n\n\n\n\n","category":"method"},{"location":"CeedVector.html#LinearAlgebra.norm-Tuple{CeedVector, Real}","page":"CeedVector","title":"LinearAlgebra.norm","text":"norm(v::CeedVector, p::Real)\n\nReturn the norm of the given CeedVector, see norm(::CeedVector, ::NormType).\n\np can have value 1, 2, or Inf, corresponding to NORM_1, NORM_2, and NORM_MAX, respectively.\n\n\n\n\n\n","category":"method"},{"location":"CeedVector.html#LibCEED.@witharray","page":"CeedVector","title":"LibCEED.@witharray","text":"@witharray(v_arr=v, [size=(dims...)], [mtype=MEM_HOST], body)\n\nExecutes body, having extracted the contents of the CeedVector v as an array with name v_arr. If the memory type mtype is not provided, MEM_HOST will be used. If the size is not specified, a flat vector will be assumed.\n\nExamples\n\nNegate the contents of CeedVector v:\n\n@witharray v_arr=v v_arr .*= -1.0\n\n\n\n\n\n","category":"macro"},{"location":"CeedVector.html#LibCEED.@witharray_read","page":"CeedVector","title":"LibCEED.@witharray_read","text":"@witharray_read(v_arr=v, [size=(dims...)], [mtype=MEM_HOST], body)\n\nSame as @witharray, but provides read-only access to the data.\n\n\n\n\n\n","category":"macro"},{"location":"CeedVector.html#LibCEED.witharray","page":"CeedVector","title":"LibCEED.witharray","text":"witharray(f, v::CeedVector, mtype=MEM_HOST)\n\nCalls f with an array containing the data of the CeedVector v, using memory type mtype.\n\nBecause of performance issues involving closures, if f is a complex operation, it may be more efficient to use the macro version @witharray (cf. the section on \"Performance of captured variable\" in the Julia documentation and related GitHub issue.\n\nExamples\n\nReturn the sum of a vector:\n\nwitharray(sum, v)\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#LibCEED.witharray_read","page":"CeedVector","title":"LibCEED.witharray_read","text":"witharray_read(f, v::CeedVector, mtype::MemType=MEM_HOST)\n\nSame as witharray, but with read-only access to the data.\n\nExamples\n\nDisplay the contents of a vector:\n\nwitharray_read(display, v)\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#LibCEED.setarray!","page":"CeedVector","title":"LibCEED.setarray!","text":"setarray!(v::CeedVector, mtype::MemType, cmode::CopyMode, arr)\n\nSet the array used by a CeedVector, freeing any previously allocated array if applicable. The backend may copy values to a different MemType. See also syncarray! and takearray!.\n\nwarning: Avoid OWN_POINTER CopyMode\nThe CopyMode OWN_POINTER is not suitable for use with arrays that are allocated by Julia, since those cannot be properly freed from libCEED.\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#LibCEED.syncarray!","page":"CeedVector","title":"LibCEED.syncarray!","text":"syncarray!(v::CeedVector, mtype::MemType)\n\nSync the CeedVector to a specified MemType. This function is used to force synchronization of arrays set with setarray!. If the requested memtype is already synchronized, this function results in a no-op.\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#LibCEED.takearray!","page":"CeedVector","title":"LibCEED.takearray!","text":"takearray!(v::CeedVector, mtype::MemType)\n\nTake ownership of the CeedVector array and remove the array from the CeedVector. The caller is responsible for managing and freeing the array. The array is returns as a Ptr{CeedScalar}.\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#LibCEED.scale!","page":"CeedVector","title":"LibCEED.scale!","text":"scale!(v::CeedVector, a::CeedScalar)\n\nOverwrites v with a*v for scalar a. Returns v.\n\n\n\n\n\n","category":"function"},{"location":"CeedVector.html#LinearAlgebra.axpy!-Tuple{Float64, CeedVector, CeedVector}","page":"CeedVector","title":"LinearAlgebra.axpy!","text":"axpy!(a::CeedScalar, x::CeedVector, y::CeedVector)\n\nOverwrite y with x*a + y, where a is a scalar. Returns y.\n\nwarning: Different argument order\nIn order to be consistent with LinearAlgebra.axpy!, the arguments are passed in order: a, x, y. This is different than the order of arguments of the C function CeedVectorAXPY.\n\n\n\n\n\n","category":"method"},{"location":"CeedVector.html#LibCEED.pointwisemult!","page":"CeedVector","title":"LibCEED.pointwisemult!","text":"pointwisemult!(w::CeedVector, x::CeedVector, y::CeedVector)\n\nOverwrite w with x .* y. Any subset of x, y, and w may be the same vector. Returns w.\n\n\n\n\n\n","category":"function"},{"location":"Context.html#Context","page":"Context","title":"Context","text":"","category":"section"},{"location":"Context.html","page":"Context","title":"Context","text":"Context","category":"page"},{"location":"Context.html#LibCEED.Context","page":"Context","title":"LibCEED.Context","text":"Context(ceed::Ceed, data; mtype=MEM_HOST, cmode=USE_POINTER)\n\nCreate a CeedQFunctionContext object that allows user Q-functions to access an arbitrary data object. data should be an instance of a mutable struct. If the copy mode cmode is USE_POINTER, then the data will be preserved from the GC when assigned to a QFunction object using set_context!.\n\nCopy mode OWN_POINTER is not supported by this interface because Julia-allocated objects cannot be freed from C.\n\n\n\n\n\n","category":"type"},{"location":"Examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"LibCEED.jl includes three short examples, which are analogues of the two examples in libCEED/examples/ceed.","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"These examples are:","category":"page"},{"location":"Examples.html","page":"Examples","title":"Examples","text":"ex1-volume-c.jl, an almost one-to-one translation of ex1-volume.c, using the low-level C interface. This example uses low-level user Q-functions defined in ex1-function-c.jl.\nex1-volume.jl, a higher-level more idiomatic version of ex1-volume.c, using user Q-functions defined using @interior_qf.\nex2-surface.jl, a higher-level, idiomatic version of ex2-surface.c.","category":"page"},{"location":"Ceed.html#Ceed","page":"Ceed","title":"Ceed","text":"","category":"section"},{"location":"Ceed.html","page":"Ceed","title":"Ceed","text":"Ceed\ngetresource\nget_preferred_memtype\nisdeterministic\niscuda\nceedversion\nisrelease","category":"page"},{"location":"Ceed.html#LibCEED.Ceed","page":"Ceed","title":"LibCEED.Ceed","text":"Ceed(spec=\"/cpu/self\")\n\nWraps a libCEED Ceed object, created with the given resource specification string.\n\n\n\n\n\n","category":"type"},{"location":"Ceed.html#LibCEED.getresource","page":"Ceed","title":"LibCEED.getresource","text":"getresource(c::Ceed)\n\nReturns the resource string associated with the given Ceed object.\n\n\n\n\n\n","category":"function"},{"location":"Ceed.html#LibCEED.get_preferred_memtype","page":"Ceed","title":"LibCEED.get_preferred_memtype","text":"get_preferred_memtype(c::Ceed)\n\nReturns the preferred MemType (either MEM_HOST or MEM_DEVICE) of the given Ceed object.\n\n\n\n\n\n","category":"function"},{"location":"Ceed.html#LibCEED.isdeterministic","page":"Ceed","title":"LibCEED.isdeterministic","text":"isdeterministic(c::Ceed)\n\nReturns true if backend of the given Ceed object is deterministic, and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Ceed.html#LibCEED.iscuda","page":"Ceed","title":"LibCEED.iscuda","text":"iscuda(c::Ceed)\n\nReturns true if the given Ceed object has resource \"/gpu/cuda/*\" and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"Ceed.html#LibCEED.ceedversion","page":"Ceed","title":"LibCEED.ceedversion","text":"ceedversion()\n\nReturns a VersionNumber corresponding to the version of the libCEED library currently used.\n\n\n\n\n\n","category":"function"},{"location":"Ceed.html#LibCEED.isrelease","page":"Ceed","title":"LibCEED.isrelease","text":"isrelease()\n\nReturns true if the libCEED library is a release build, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"QFunction.html#QFunction","page":"QFunction","title":"QFunction","text":"","category":"section"},{"location":"QFunction.html","page":"QFunction","title":"QFunction","text":"QFunction\n@interior_qf\ncreate_interior_qfunction(::Ceed, ::AbstractString)\ncreate_identity_qfunction\nset_context!\napply!(qf::QFunction, Q, vin, vout)","category":"page"},{"location":"QFunction.html#LibCEED.QFunction","page":"QFunction","title":"LibCEED.QFunction","text":"QFunction\n\nA libCEED CeedQFunction object, typically created using the @interior_qf macro.\n\nA QFunction can also be created from the \"Q-function gallery\" using create_interior_qfunction. The identity Q-function can be created using create_identity_qfunction.\n\n\n\n\n\n","category":"type"},{"location":"QFunction.html#LibCEED.@interior_qf","page":"QFunction","title":"LibCEED.@interior_qf","text":"@interior_qf name=def\n\nCreates a user-defined interior (volumetric) Q-function, and assigns it to a variable named name. The definition of the Q-function is given as:\n\n@interior_qf user_qf=(\n    ceed::CEED,\n    [const1=val1, const2=val2, ...],\n    [ctx::ContextType],\n    (I1, :in, EvalMode, dims...),\n    (I2, :in, EvalMode, dims...),\n    (O1, :out, EvalMode, dims...),\n    body\n)\n\nThe definitions of form const=val are used for definitions which will be compile-time constants in the Q-function. For example, if dim is a variable set to the dimension of the problem, then dim=dim will make dim available in the body of the Q-function as a compile-time constant.\n\nIf the user wants to provide a context struct to the Q-function, that can be achieved by optionally including ctx::ContextType, where ContextType is the type of the context struct, and ctx is the name to which is will be bound in the body of the Q-function.\n\nThis is followed by the definition of the input and output arrays, which take the form (arr_name, (:in|:out), EvalMode, dims...). Each array will be bound to a variable named arr_name. Input arrays should be tagged with :in, and output arrays with :out. An EvalMode should be specified, followed by the dimensions of the array. If the array consists of scalars (one number per Q-point) then dims should be omitted.\n\nExamples\n\nQ-function to compute the \"Q-data\" for the mass operator, which is given by the quadrature weight times the Jacobian determinant. The mesh Jacobian (the gradient of the nodal mesh points) and the quadrature weights are given as input arrays, and the Q-data is the output array. dim is given as a compile-time constant, and so the array J is statically sized, and therefore det(J) will automatically dispatch to an optimized implementation for the given dimension.\n\n@interior_qf build_qfunc = (\n    ceed, dim=dim,\n    (J, :in, EVAL_GRAD, dim, dim),\n    (w, :in, EVAL_WEIGHT),\n    (qdata, :out, EVAL_NONE),\n    qdata[] = w*det(J)\n)\n\n\n\n\n\n","category":"macro"},{"location":"QFunction.html#LibCEED.create_interior_qfunction-Tuple{Ceed, AbstractString}","page":"QFunction","title":"LibCEED.create_interior_qfunction","text":"create_interior_qfunction(ceed::Ceed, name::AbstractString)\n\nCreate a QFunction from the Q-function gallery, using the provided name.\n\nExamples\n\nBuild and apply the 3D mass operator\n\nbuild_mass_qf = create_interior_qfunction(c, \"Mass3DBuild\")\napply_mass_qf = create_interior_qfunction(c, \"MassApply\")\n\nBuild and apply the 3D Poisson operator\n\nbuild_poi_qf = create_interior_qfunction(c, \"Poisson3DBuild\")\napply_poi_qf = create_interior_qfunction(c, \"Poisson3DApply\")\n\n\n\n\n\n","category":"method"},{"location":"QFunction.html#LibCEED.create_identity_qfunction","page":"QFunction","title":"LibCEED.create_identity_qfunction","text":"create_identity_qfunction(c::Ceed, size, inmode::EvalMode, outmode::EvalMode)\n\nCreate an identity QFunction. Inputs are written into outputs in the order given. This is useful for Operators that can be represented with only the action of a ElemRestriction and Basis, such as restriction and prolongation operators for p-multigrid. Backends may optimize CeedOperators with this Q-function to avoid the copy of input data to output fields by using the same memory location for both.\n\n\n\n\n\n","category":"function"},{"location":"QFunction.html#LibCEED.set_context!","page":"QFunction","title":"LibCEED.set_context!","text":"set_context!(qf::QFunction, ctx::Context)\n\nAssociate a Context object ctx with the given Q-function qf.\n\n\n\n\n\n","category":"function"},{"location":"QFunction.html#LibCEED.apply!-Tuple{QFunction, Any, Any, Any}","page":"QFunction","title":"LibCEED.apply!","text":"apply!(qf::QFunction, Q, vin, vout)\n\nApply the action of a QFunction to an array of input vectors, and store the result in an array of output vectors.\n\n\n\n\n\n","category":"method"},{"location":"ElemRestriction.html#ElemRestriction","page":"ElemRestriction","title":"ElemRestriction","text":"","category":"section"},{"location":"ElemRestriction.html","page":"ElemRestriction","title":"ElemRestriction","text":"ElemRestriction\nElemRestrictionNone\ncreate_elem_restriction\ncreate_elem_restriction_strided\napply!(r::ElemRestriction, u::CeedVector, ru::CeedVector; tmode=NOTRANSPOSE, request=RequestImmediate())\napply(r::ElemRestriction, u::AbstractVector; tmode=NOTRANSPOSE)\ncreate_evector\ncreate_lvector\ncreate_vectors\ngetcompstride\ngetnumelements\ngetelementsize\ngetlvectorsize\ngetnumcomponents(r::ElemRestriction)\ngetmultiplicity!\ngetmultiplicity","category":"page"},{"location":"ElemRestriction.html#LibCEED.ElemRestriction","page":"ElemRestriction","title":"LibCEED.ElemRestriction","text":"ElemRestriction\n\nWraps a CeedElemRestriction object, representing the restriction from local vectors to elements. An ElemRestriction object can be created using create_elem_restriction or create_elem_restriction_strided.\n\n\n\n\n\n","category":"type"},{"location":"ElemRestriction.html#LibCEED.ElemRestrictionNone","page":"ElemRestriction","title":"LibCEED.ElemRestrictionNone","text":"ElemRestrictionNone()\n\nReturns the singleton object corresponding to libCEED's CEED_ELEMRESTRICTION_NONE\n\n\n\n\n\n","category":"type"},{"location":"ElemRestriction.html#LibCEED.create_elem_restriction","page":"ElemRestriction","title":"LibCEED.create_elem_restriction","text":"create_elem_restriction(\n    ceed::Ceed,\n    nelem,\n    elemsize,\n    ncomp,\n    compstride,\n    lsize,\n    offsets::AbstractArray{CeedInt},\n    mtype::MemType=MEM_HOST,\n    cmode::CopyMode=COPY_VALUES,\n)\n\nCreate a CeedElemRestriction.\n\nwarning: Zero-based indexing\nIn the below notation, we are using 0-based indexing. libCEED expects the offset indices to be 0-based.\n\nArguments:\n\nceed:       The Ceed object\nnelem:      Number of elements described in the offsets array\nelemsize:   Size (number of \"nodes\") per element\nncomp:      Number of field components per interpolation node (1 for scalar fields)\ncompstride: Stride between components for the same L-vector \"node\". Data for node i,               component j, element k can be found in the L-vector at index offsets[i               + k*elemsize] + j*compstride.\nlsize:      The size of the L-vector. This vector may be larger than the elements and               fields given by this restriction.\noffsets:    Array of shape (elemsize, nelem). Column i holds the ordered list of the               offsets (into the input CeedVector) for the unknowns corresponding               to element i, where 0 leq i  textitnelem. All offsets must be in               the range 0 textitlsize - 1.\nmtype:      Memory type of the offsets array, see MemType\ncmode:      Copy mode for the offsets array, see CopyMode\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.create_elem_restriction_strided","page":"ElemRestriction","title":"LibCEED.create_elem_restriction_strided","text":"create_elem_restriction_strided(ceed::Ceed, nelem, elemsize, ncomp, lsize, strides)\n\nCreate a strided CeedElemRestriction.\n\nwarning: Zero-based indexing\nIn the below notation, we are using 0-based indexing. libCEED expects the offset indices to be 0-based.\n\nArguments:\n\nceed:     The Ceed object\nnelem:    Number of elements described by the restriction\nelemsize: Size (number of \"nodes\") per element\nncomp:    Number of field components per interpolation node (1 for scalar fields)\nlsize:    The size of the L-vector. This vector may be larger than the elements and             fields given by this restriction.\nstrides:  Array for strides between [nodes, components, elements]. Data for node i,             component j, element k can be found in the L-vector at index i*strides[0]             + j*strides[1] + k*strides[2]. STRIDES_BACKEND may be used with             vectors created by a Ceed backend.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.apply!-Tuple{ElemRestriction, CeedVector, CeedVector}","page":"ElemRestriction","title":"LibCEED.apply!","text":"apply!(\n    r::ElemRestriction,\n    u::CeedVector,\n    ru::CeedVector;\n    tmode=NOTRANSPOSE,\n    request=RequestImmediate(),\n)\n\nUse the ElemRestriction to convert from L-vector to an E-vector (or apply the tranpose operation). The input CeedVector is u and the result stored in ru.\n\nIf tmode is TRANSPOSE, then the result is added to ru. If tmode is NOTRANSPOSE, then ru is overwritten with the result.\n\n\n\n\n\n","category":"method"},{"location":"ElemRestriction.html#LibCEED.apply-Tuple{ElemRestriction, AbstractVector{T} where T}","page":"ElemRestriction","title":"LibCEED.apply","text":"apply(r::ElemRestriction, u::AbstractVector; tmode=NOTRANSPOSE)\n\nUse the ElemRestriction to convert from L-vector to an E-vector (or apply the tranpose operation). The input is given by u, and the result is returned as an array of type Vector{CeedScalar}.\n\n\n\n\n\n","category":"method"},{"location":"ElemRestriction.html#LibCEED.create_evector","page":"ElemRestriction","title":"LibCEED.create_evector","text":"create_evector(r::ElemRestriction)\n\nReturn a new CeedVector E-vector.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.create_lvector","page":"ElemRestriction","title":"LibCEED.create_lvector","text":"create_lvector(r::ElemRestriction)\n\nReturn a new CeedVector L-vector.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.create_vectors","page":"ElemRestriction","title":"LibCEED.create_vectors","text":"create_vectors(r::ElemRestriction)\n\nReturn an (L-vector, E-vector) pair.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.getcompstride","page":"ElemRestriction","title":"LibCEED.getcompstride","text":"getcompstride(r::ElemRestriction)\n\nGet the L-vector component stride.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.getnumelements","page":"ElemRestriction","title":"LibCEED.getnumelements","text":"getnumelements(r::ElemRestriction)\n\nGet the total number of elements in the range of an ElemRestriction.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.getelementsize","page":"ElemRestriction","title":"LibCEED.getelementsize","text":"getelementsize(r::ElemRestriction)\n\nGet the size of elements in the given ElemRestriction.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.getlvectorsize","page":"ElemRestriction","title":"LibCEED.getlvectorsize","text":"getlvectorsize(r::ElemRestriction)\n\nGet the size of an L-vector for the given ElemRestriction.\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.getnumcomponents-Tuple{ElemRestriction}","page":"ElemRestriction","title":"LibCEED.getnumcomponents","text":"getnumcomponents(r::ElemRestriction)\n\nGet the number of components in the elements of an ElemRestriction.\n\n\n\n\n\n","category":"method"},{"location":"ElemRestriction.html#LibCEED.getmultiplicity!","page":"ElemRestriction","title":"LibCEED.getmultiplicity!","text":"getmultiplicity!(r::ElemRestriction, v::AbstractCeedVector)\n\nGet the multiplicity of nodes in an ElemRestriction. The CeedVector v should be an L-vector (i.e. length(v) == getlvectorsize(r), see create_lvector).\n\n\n\n\n\n","category":"function"},{"location":"ElemRestriction.html#LibCEED.getmultiplicity","page":"ElemRestriction","title":"LibCEED.getmultiplicity","text":"getmultiplicity(r::ElemRestriction)\n\nConvenience function to get the multiplicity of nodes in the ElemRestriction, where the result is returned in a newly allocated Julia Vector{CeedScalar} (see also getmultiplicity!).\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#Basis","page":"Basis","title":"Basis","text":"","category":"section"},{"location":"Basis.html","page":"Basis","title":"Basis","text":"info: Column-major vs. row-major storage\nlibCEED internally uses row-major (C convention) storage of matrices, while Julia uses column-major (Fortran convention) storage.LibCEED.jl will typically handle the conversion between these formats by transposing or permuting the dimensions of the input and output matrices and tensors.","category":"page"},{"location":"Basis.html","page":"Basis","title":"Basis","text":"Basis\nBasisCollocated\ncreate_tensor_h1_lagrange_basis\ncreate_tensor_h1_basis\ncreate_h1_basis\napply!(b::Basis, nelem, tmode::TransposeMode, emode::EvalMode, u::LibCEED.AbstractCeedVector, v::LibCEED.AbstractCeedVector)\napply(b::Basis, u::AbstractVector; nelem=1, tmode=NOTRANSPOSE, emode=EVAL_INTERP)\ngetdimension\ngettopology\ngetnumcomponents(b::Basis)\ngetnumnodes\ngetnumnodes1d\ngetnumqpts\ngetnumqpts1d\ngetqref\ngetqweights\ngetinterp\ngetinterp1d\ngetgrad\ngetgrad1d","category":"page"},{"location":"Basis.html#LibCEED.Basis","page":"Basis","title":"LibCEED.Basis","text":"Basis\n\nWraps a CeedBasis object, representing a finite element basis. A Basis object can be created using one of:\n\ncreate_tensor_h1_lagrange_basis\ncreate_tensor_h1_basis\ncreate_h1_basis\n\n\n\n\n\n","category":"type"},{"location":"Basis.html#LibCEED.BasisCollocated","page":"Basis","title":"LibCEED.BasisCollocated","text":"BasisCollocated()\n\nReturns the singleton object corresponding to libCEED's CEED_BASIS_COLLOCATED.\n\n\n\n\n\n","category":"type"},{"location":"Basis.html#LibCEED.create_tensor_h1_lagrange_basis","page":"Basis","title":"LibCEED.create_tensor_h1_lagrange_basis","text":"create_tensor_h1_lagrange_basis(ceed, dim, ncomp, p, q, qmode)\n\nCreate a tensor-product Lagrange basis.\n\nArguments:\n\nceed:  A Ceed object where the Basis will be created.\ndim:   Topological dimension of element.\nncomp: Number of field components (1 for scalar fields).\np:     Number of Gauss-Lobatto nodes in one dimension.  The polynomial degree of the          resulting Q_k element is k=p-1.\nq:     Number of quadrature points in one dimension.\nqmode: Distribution of the q quadrature points (affects order of accuracy for the          quadrature).\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.create_tensor_h1_basis","page":"Basis","title":"LibCEED.create_tensor_h1_basis","text":"create_tensor_h1_basis(c::Ceed, dim, ncomp, p, q, interp1d, grad1d, qref1d, qweight1d)\n\nCreate a tensor-product basis for H^1 discretizations.\n\nArguments:\n\nceed:      A Ceed object where the Basis will be created.\ndim:       Topological dimension.\nncomp:     Number of field components (1 for scalar fields).\np:         Number of nodes in one dimension.\nq:         Number of quadrature points in one dimension\ninterp1d:  Matrix of size (q, p) expressing the values of nodal basis functions at              quadrature points.\ngrad1d:    Matrix of size (p, q) expressing derivatives of nodal basis functions at              quadrature points.\nqref1d:    Array of length q holding the locations of quadrature points on the 1D              reference element -1 1.\nqweight1d: Array of length q holding the quadrature weights on the reference element.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.create_h1_basis","page":"Basis","title":"LibCEED.create_h1_basis","text":"create_h1_basis(c::Ceed, topo::Topology, ncomp, nnodes, nqpts, interp, grad, qref, qweight)\n\nCreate a non tensor-product basis for H^1 discretizations\n\nArguments:\n\nceed:    A Ceed object where the Basis will be created.\ntopo:    Topology of element, e.g. hypercube, simplex, etc.\nncomp:   Number of field components (1 for scalar fields).\nnnodes:  Total number of nodes.\nnqpts:   Total number of quadrature points.\ninterp:  Matrix of size (nqpts, nnodes) expressing the values of nodal basis functions            at quadrature points.\ngrad:    Array of size (dim, nqpts, nnodes) expressing derivatives of nodal basis            functions at quadrature points.\nqref:    Array of length nqpts holding the locations of quadrature points on the            reference element -1 1.\nqweight: Array of length nqpts holding the quadrature weights on the reference            element.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.apply!-Tuple{Basis, Any, LibCEED.C.CeedTransposeMode, LibCEED.C.CeedEvalMode, LibCEED.AbstractCeedVector, LibCEED.AbstractCeedVector}","page":"Basis","title":"LibCEED.apply!","text":"apply!(b::Basis, nelem, tmode::TransposeMode, emode::EvalMode, u::AbstractCeedVector, v::AbstractCeedVector)\n\nApply basis evaluation from nodes to quadrature points or vice versa, storing the result in the CeedVector v.\n\nnelem specifies the number of elements to apply the basis evaluation to; the backend will specify the ordering in CeedElemRestrictionCreateBlocked()\n\nSet tmode to CEED_NOTRANSPOSE to evaluate from nodes to quadrature or to CEED_TRANSPOSE to apply the transpose, mapping from quadrature points to nodes.\n\nSet the EvalMode emode to:\n\nCEED_EVAL_NONE to use values directly,\nCEED_EVAL_INTERP to use interpolated values,\nCEED_EVAL_GRAD to use gradients,\nCEED_EVAL_WEIGHT to use quadrature weights.\n\n\n\n\n\n","category":"method"},{"location":"Basis.html#LibCEED.apply-Tuple{Basis, AbstractVector{T} where T}","page":"Basis","title":"LibCEED.apply","text":"apply(b::Basis, u::AbstractVector; nelem=1, tmode=NOTRANSPOSE, emode=EVAL_INTERP)\n\nPerforms the same function as the above-defined apply!, but automatically convert from Julia arrays to CeedVector for convenience.\n\nThe result will be returned in a newly allocated array of the correct size.\n\n\n\n\n\n","category":"method"},{"location":"Basis.html#LibCEED.getdimension","page":"Basis","title":"LibCEED.getdimension","text":"getdimension(b::Basis)\n\nReturn the spatial dimension of the given Basis.\n\n\n\n\n\ngetdimension(t::Topology)\n\nReturn the spatial dimension of the given Topology.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.gettopology","page":"Basis","title":"LibCEED.gettopology","text":"gettopology(b::Basis)\n\nReturn the Topology of the given Basis.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getnumcomponents-Tuple{Basis}","page":"Basis","title":"LibCEED.getnumcomponents","text":"getnumcomponents(b::Basis)\n\nReturn the number of components of the given Basis.\n\n\n\n\n\n","category":"method"},{"location":"Basis.html#LibCEED.getnumnodes","page":"Basis","title":"LibCEED.getnumnodes","text":"getnumnodes(b::Basis)\n\nReturn the number of nodes of the given Basis.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getnumnodes1d","page":"Basis","title":"LibCEED.getnumnodes1d","text":"getnumnodes1d(b::Basis)\n\nReturn the number of 1D nodes of the given (tensor-product) [`Basis`](@ref).\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getnumqpts","page":"Basis","title":"LibCEED.getnumqpts","text":"getnumqpts(b::Basis)\n\nReturn the number of quadrature points of the given Basis.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getnumqpts1d","page":"Basis","title":"LibCEED.getnumqpts1d","text":"getnumqpts1d(b::Basis)\n\nReturn the number of 1D quadrature points of the given (tensor-product) Basis.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getqref","page":"Basis","title":"LibCEED.getqref","text":"getqref(b::Basis)\n\nGet the reference coordinates of quadrature points (in dim dimensions) of the given Basis.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getqweights","page":"Basis","title":"LibCEED.getqweights","text":"getqref(b::Basis)\n\nGet the quadrature weights of quadrature points (in dim dimensions) of the given Basis.\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getinterp","page":"Basis","title":"LibCEED.getinterp","text":"getinterp(b::Basis)\n\nGet the interpolation matrix of the given Basis. Returns a matrix of size (getnumqpts(b), getnumnodes(b)).\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getinterp1d","page":"Basis","title":"LibCEED.getinterp1d","text":"getinterp1d(b::Basis)\n\nGet the 1D interpolation matrix of the given Basis. b must be a tensor-product basis, otherwise this function will fail. Returns a matrix of size (getnumqpts1d(b), getnumnodes1d(b)).\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getgrad","page":"Basis","title":"LibCEED.getgrad","text":"getgad(b::Basis)\n\nGet the gradient matrix of the given Basis. Returns a tensor of size (getdimension(b), getnumqpts(b), getnumnodes(b)).\n\n\n\n\n\n","category":"function"},{"location":"Basis.html#LibCEED.getgrad1d","page":"Basis","title":"LibCEED.getgrad1d","text":"getgrad1d(b::Basis)\n\nGet the 1D derivative matrix of the given Basis. Returns a matrix of size (getnumqpts(b), getnumnodes(b)).\n\n\n\n\n\n","category":"function"},{"location":"Globals.html#Constants-and-Enumerations","page":"Constants and Enumerations","title":"Constants and Enumerations","text":"","category":"section"},{"location":"Globals.html","page":"Constants and Enumerations","title":"Constants and Enumerations","text":"CeedScalar\nCeedInt\nQuadMode\nMemType\nCopyMode\nEvalMode\nTransposeMode\nNormType\nTopology\nSTRIDES_BACKEND","category":"page"},{"location":"Globals.html#LibCEED.CeedScalar","page":"Constants and Enumerations","title":"LibCEED.CeedScalar","text":"CeedScalar\n\nScalar (floating point) type. Equivalent to Float64.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.CeedInt","page":"Constants and Enumerations","title":"LibCEED.CeedInt","text":"CeedInt\n\nInteger type, used for indexing. Equivalent to Int32.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.QuadMode","page":"Constants and Enumerations","title":"LibCEED.QuadMode","text":"QuadMode\n\nOne of GAUSS or GAUSS_LOBATTO.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.MemType","page":"Constants and Enumerations","title":"LibCEED.MemType","text":"MemType\n\nOne of MEM_HOST or MEM_DEVICE.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.CopyMode","page":"Constants and Enumerations","title":"LibCEED.CopyMode","text":"CopyMode\n\nOne of COPY_VALUES, USE_POINTER or OWN_POINTER.\n\nOWN_POINTER is not typically supported for objects created in Julia, because those must be destroyed by the garbage collector, and cannot be freed from C.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.EvalMode","page":"Constants and Enumerations","title":"LibCEED.EvalMode","text":"EvalMode\n\nEvaluation mode used in the specification of input and output fields for Q-functions, e.g. in @interior_qf.\n\nOne of:\n\nEVAL_NONE\nEVAL_INTERP\nEVAL_GRAD\nEVAL_DIV\nEVAL_CURL\nEVAL_WEIGHT\n\nSee the libCEED documentation for further information.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.TransposeMode","page":"Constants and Enumerations","title":"LibCEED.TransposeMode","text":"TransposeMose\n\nDenotes whether a linear transformation or its transpose should be applied. Either NOTRANSPOSE or TRANSPOSE.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.NormType","page":"Constants and Enumerations","title":"LibCEED.NormType","text":"NormType\n\nDenotes type of vector norm. One of NORM_1, NORM_2, or NORM_MAX.\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.Topology","page":"Constants and Enumerations","title":"LibCEED.Topology","text":"Topology\n\nType of basis shape to create non-tensor H1 element basis. One of LINE, TRIANGLE, QUAD, TET, PYRAMID, PRISM, or HEX.\n\nThe dimension can be extracted with bitshift:\n\ndim = Int(topology) >> 16\n\n\n\n\n\n","category":"type"},{"location":"Globals.html#LibCEED.STRIDES_BACKEND","page":"Constants and Enumerations","title":"LibCEED.STRIDES_BACKEND","text":"STRIDES_BACKEND\n\nIndicate that the stride is determined by the backend.\n\n\n\n\n\n","category":"constant"},{"location":"UserQFunctions.html#Defining-User-Q-Functions","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"","category":"section"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"An important feature of LibCEED.jl is the ability to define user Q-functions natively in Julia. These user Q-functions work with both the CPU and CUDA backends.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"User Q-functions describe the action of the D operator at quadrature points (see libCEED's theoretical framework). Since the Q-functions are invoked at every quadrature point, efficiency is very important.","category":"page"},{"location":"UserQFunctions.html#Apply-mass-Q-function-in-C","page":"Defining User Q-Functions","title":"Apply mass Q-function in C","text":"","category":"section"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"Before describing how to define user Q-functions in Julia, we will briefly given an example of a user Q-function defined in C. This is the \"apply mass\" Q-function from ex1-volume.c, which computes the action of the mass operator. The mass operator on each element can be written as B^intercal D B, where B is the basis operator, and D represents multiplication by quadrature weights and geometric factors (i.e. the determinant of the mesh transformation Jacobian at each qudarture point). It is the action of D that the Q-function must implement. The C source of the Q-function is:","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"/// libCEED Q-function for applying a mass operator\nCEED_QFUNCTION(f_apply_mass)(void *ctx, const CeedInt Q,\n                             const CeedScalar *const *in,\n                             CeedScalar *const *out) {\n  const CeedScalar *u = in[0], *qdata = in[1];\n  CeedScalar *v = out[0];\n  // Quadrature Point Loop\n  CeedPragmaSIMD\n  for (CeedInt i=0; i<Q; i++) {\n    v[i] = qdata[i] * u[i];\n  } // End of Quadrature Point Loop\n  return 0;\n}","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"From this example, we see that a user Q-function is a C callback that takes a \"data context\" pointer, a number of quadrature points, and two arrays of arrays, one for inputs, and one for outputs.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"In this example, the first input array is u, which is the value of the trial function evaluated at each quadrature point. The second input array is qdata, which contains the precomputed geometric factors. There is only one output array, v, which will store the pointwise product of u and data. Given the definition of this Q-function, the CeedQFunction object is created by","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"CeedQFunctionCreateInterior(ceed, 1, f_apply_mass, f_apply_mass_loc, &apply_qfunc);\nCeedQFunctionAddInput(apply_qfunc, \"u\", 1, CEED_EVAL_INTERP);\nCeedQFunctionAddInput(apply_qfunc, \"qdata\", 1, CEED_EVAL_NONE);\nCeedQFunctionAddOutput(apply_qfunc, \"v\", 1, CEED_EVAL_INTERP);","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"When adding the inputs and outputs, CEED_EVAL_INTERP indicates that the B basis operator should be used to interpolate the trial and test functions from nodal points to quadrature points, and CEED_EVAL_NONE indicates that the qdata is already precomputed at quadrature points, and no interpolation is requried.","category":"page"},{"location":"UserQFunctions.html#Apply-mass-Q-function-in-Julia","page":"Defining User Q-Functions","title":"Apply mass Q-function in Julia","text":"","category":"section"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"We now replicate this Q-function in Julia. The main way of defining user Q-functions in Julia is using the @interior_qf macro. The above C code (both the definition of the Q-function, its creation, and adding the inputs and outputs) is analogous to the following Julia code:","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"@interior_qf apply_qfunc = (\n    ceed, Q,\n    (u, :in, EVAL_INTERP, Q), (qdata, :in, EVAL_NONE, Q),\n    (v, :out, EVAL_INTERP, Q),\n    @inbounds @simd for i=1:Q\n        v[i] = qdata[i]*u[i]\n    end\n)","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"This creates a QFunction object named apply_qfunc. The Q-function is defined by the tuple on the right-hand side. ceed is the name of the Ceed object where the Q-function will be created, and the second argument, Q, is the name of that variable that will contain the number of quadrature points. The next three arguments are specifications of the input and output fields:","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"    (u, :in, EVAL_INTERP, Q),\n    (qdata, :in, EVAL_NONE, Q),\n    (v, :out, EVAL_INTERP, Q),","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"Each input or output field specification is a tuple, where the first entry is the name of the array, and the second entry is either :in or :out, according to whether the array is an input or output array. The third entry is the EvalMode of the field. The remaining entries are the dimensions of the array. The first dimension is always equal to the number of quadrature points. In this case, all the arrays are simply vectors whose size is equal to the number of quadrature points, but in more sophisticated examples (e.g. the apply diffusion Q-function) these arrays could consists of vectors or matrices at each quadrature point. After providing all of the array specifications, the body of the Q-function is provided.","category":"page"},{"location":"UserQFunctions.html#applydiff","page":"Defining User Q-Functions","title":"Apply diffusion Q-function in Julia","text":"","category":"section"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"For a more sophisticated example of a Q-function, we consider the \"apply diffusion\" Q-function, used in ex2-surface. This Q-function computes the action of the diffusion operator. When written in the form B^intercal D B, in this case B represents the basis gradient matrix, and D represents multiplication by w det(J) J^-intercal J^-1, where J is the mesh transformation Jacobian, and w is the quadrature weight.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"This Q-function is implemented in Julia as follows:","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"@interior_qf apply_qfunc = (\n    ceed, Q, dim=dim,\n    (du, :in, EVAL_GRAD, Q, dim),\n    (qdata, :in, EVAL_NONE, Q, dim*(dim+1)÷2),\n    (dv, :out, EVAL_GRAD, Q, dim),\n    @inbounds @simd for i=1:Q\n        dXdxdXdxT = getvoigt(@view(qdata[i,:]), CeedDim(dim))\n        dui = SVector{dim}(@view(du[i,:]))\n        dv[i,:] .= dXdxdXdxT*dui\n    end\n)","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"In contrast to the previous example, before the field specifications, this Q-function includes a constant definition dim=dim. The @interior_qf macro allows for any number of constant definitions, which make the specified values available within the body of the Q-function as compile-time constants.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"In this example, dim is either 1, 2, or 3 according to the spatial dimension of the problem. When the user Q-function is defined, LibCEED.jl will JIT compile the body of the Q-function and make it available to libCEED as a C callback. In the body of this Q-function, dim will be available, and its value will be a compile-time constant, allowing for (static) dispatch based on the value of dim, and eliminating branching.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"Note that dim is also available for use in the field specifications. In this example, the field specifications are slightly more involved that in the previous example. The arrays are given by","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"    (du, :in, EVAL_GRAD, Q, dim),\n    (qdata, :in, EVAL_NONE, Q, dim*(dim+1)÷2),\n    (dv, :out, EVAL_GRAD, Q, dim),","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"Note that the input array du has EvalMode EVAL_GRAD, meaning that this array stores the gradient of the trial function at each quadrature point. Therefore, at each quadrature point, du stores a vector of length dim, and so the shape of du is (Q, dim). Similarly, the action of D is given by w det(J) J^-intercal J^-1 nabla u, which is also a vector of length dim at each quadrature point. This means that the output array dv also has shape (Q, dim).","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"The geometric factors stored in qdata represent the symmetric matrix w det(J) J^-intercal J^-1 evaluated at every quadrature point. In order to reduce data usage, instead of storing this data as a d times d matrix, we use the fact that we know it is symmetric to only store d(d+1)2 entries, and the remaining entries we infer by symmetry. These entries are stored using the Voigt convention. LibCEED.jl provides some utilities for storing and extracting symmetric matrices stored in this fashion.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"After the field specifications, we have the body of the Q-function:","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"@inbounds @simd for i=1:Q\n    dXdxdXdxT = getvoigt(@view(qdata[i,:]), CeedDim(dim))\n    dui = SVector{dim}(@view(du[i,:]))\n    dv[i,:] .= dXdxdXdxT*dui\nend","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"First, the matrix w det(J) J^-intercal J^-1 is stored in the variable dXdxdXdxT. The symmetric entries of this matrix are accesed using @view(qdata[i,:]), which avoids allocations. getvoigt is used to convert from Voigt notation to a symmetric matrix, which returns a statically sized SMatrix. The version for the correct spatial dimension is selected using CeedDim(dim), which allows for compile-time dispatch, since dim is a constant whose value is known as a constant when the Q-function is JIT compiled.","category":"page"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"Then, the gradient of u at the given quadrature point is loaded as a fixed-size SVector. The result is placed into the output array, where the StaticArrays.jl package evaluates dXdxdXdxT*dui using an optimized matrix-vector product for small matrices (since their sizes are known statically).","category":"page"},{"location":"UserQFunctions.html#GPU-Kernels","page":"Defining User Q-Functions","title":"GPU Kernels","text":"","category":"section"},{"location":"UserQFunctions.html","page":"Defining User Q-Functions","title":"Defining User Q-Functions","text":"If the Ceed resource uses a CUDA backend, then the user Q-functions defined using @interior_qf are automatically compiled as CUDA kernels using CUDA.jl. Some Julia features are not available in GPU code (for example, dynamic dispatch), so if the Q-function is intended to be run on the GPU, the user should take care when defining the body of the user Q-function.","category":"page"},{"location":"Operator.html#Operator","page":"Operator","title":"Operator","text":"","category":"section"},{"location":"Operator.html","page":"Operator","title":"Operator","text":"Operator\ncreate_composite_operator\napply!(op::Operator, vin::LibCEED.AbstractCeedVector, vout::LibCEED.AbstractCeedVector; request)\napply_add!\nassemble_diagonal!\nassemble_add_diagonal!","category":"page"},{"location":"Operator.html#LibCEED.Operator","page":"Operator","title":"LibCEED.Operator","text":"Operator(ceed::Ceed; qf, dqf=QFunctionNone(), dqfT=QFunctionNone(), fields)\n\nCreates a libCEED CeedOperator object using the given Q-function qf, and optionally its derivative and derivative transpose.\n\nAn array of fields must be provided, where each element of the array is a tuple containing the name of the field (as a string or symbol), the corresponding element restriction, basis, and vector.\n\nExamples\n\nCreate the operator that builds the Q-data associated with the mass matrix.\n\nbuild_oper = Operator(\n    ceed,\n    qf=build_qfunc,\n    fields=[\n        (:J, mesh_restr, mesh_basis, CeedVectorActive()),\n        (:w, ElemRestrictionNone(), mesh_basis, CeedVectorNone()),\n        (:qdata, sol_restr_i, BasisCollocated(), CeedVectorActive())\n    ]\n)\n\n\n\n\n\n","category":"type"},{"location":"Operator.html#LibCEED.create_composite_operator","page":"Operator","title":"LibCEED.create_composite_operator","text":"create_composite_operator(c::Ceed, ops)\n\nCreate an Operator whose action represents the sum of the operators in the collection ops.\n\n\n\n\n\n","category":"function"},{"location":"Operator.html#LibCEED.apply!-Tuple{Operator, LibCEED.AbstractCeedVector, LibCEED.AbstractCeedVector}","page":"Operator","title":"LibCEED.apply!","text":"apply!(op::Operator, vin, vout; request=RequestImmediate())\n\nApply the action of the operator op to the input vector vin, and store the result in the output vector vout.\n\nFor non-blocking application, the user can specify a request object. By default, immediate (synchronous) completion is requested.\n\n\n\n\n\n","category":"method"},{"location":"Operator.html#LibCEED.apply_add!","page":"Operator","title":"LibCEED.apply_add!","text":"apply_add!(op::Operator, vin, vout; request=RequestImmediate())\n\nApply the action of the operator op to the input vector vin, and add the result to the output vector vout.\n\nFor non-blocking application, the user can specify a request object. By default, immediate (synchronous) completion is requested.\n\n\n\n\n\n","category":"function"},{"location":"Operator.html#LibCEED.assemble_diagonal!","page":"Operator","title":"LibCEED.assemble_diagonal!","text":"assemble_diagonal!(op::Operator, diag::CeedVector; request=RequestImmediate())\n\nOverwrites a CeedVector with the diagonal of a linear Operator.\n\nnote: Note:\nCurrently only Operators with a single field are supported.\n\n\n\n\n\n","category":"function"},{"location":"Operator.html#LibCEED.assemble_add_diagonal!","page":"Operator","title":"LibCEED.assemble_add_diagonal!","text":"assemble_diagonal!(op::Operator, diag::CeedVector; request=RequestImmediate())\n\nAdds the diagonal of a linear Operator to the given CeedVector.\n\nnote: Note:\nCurrently only Operators with a single field are supported.\n\n\n\n\n\n","category":"function"},{"location":"Quadrature.html#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"Quadrature.html","page":"Quadrature","title":"Quadrature","text":"gauss_quadrature\nlobatto_quadrature","category":"page"},{"location":"Quadrature.html#LibCEED.gauss_quadrature","page":"Quadrature","title":"LibCEED.gauss_quadrature","text":"gauss_quadrature(q)\n\nReturn the Gauss-Legendre quadrature rule with q points (integrates polynomials of degree 2q-1 exactly).\n\nA tuple (x,w) is returned.\n\n\n\n\n\n","category":"function"},{"location":"Quadrature.html#LibCEED.lobatto_quadrature","page":"Quadrature","title":"LibCEED.lobatto_quadrature","text":"lobatto_quadrature(q, mode::Mode=Abscissa)\n\nReturn the Gauss-Lobatto quadrature rule with q points (integrates polynomials of degree 2q-3 exactly).\n\nIf mode is AbscissaAndWeights, then both the weights and abscissa are returned as a tuple (x,w).\n\nOtherwise, (if mode is Abscissa), then only the abscissa x are returned.\n\n\n\n\n\n","category":"function"},{"location":"index.html#LibCEED.jl-Docs","page":"Home","title":"LibCEED.jl Docs","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Documentation for the LibCEED.jl Julia interface to the libCEED library.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For further information, see also the libCEED documentation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Several short examples are included to demonstrate the functionality.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The LibCEED.jl package can be installed with Julia's package manager by running ] add LibCEED. This will automatically install a pre-built binary of the libCEED library. If you require features of a specific build of libCEED (e.g. CUDA/GPU support, specific compiler flags, etc.) then you should compile your own version of the libCEED library, and configure LibCEED.jl to use this binary as described in the Configuring LibCEED.jl section.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: The pre-built libCEED binaries do not support CUDA backends\nThe pre-built binaries automatically installed by LibCEED.jl (through the libCEED_jll package) are not built with CUDA support. If you want to run libCEED on the GPU, you will have to build libCEED from source and configure LibCEED.jl as described in the Configuring LibCEED.jl section.","category":"page"},{"location":"index.html#Configuring-LibCEED.jl","page":"Home","title":"Configuring LibCEED.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"By default, LibCEED.jl will use the pre-built libCEED binaries provided by the libCEED_jll package. If you wish to use a different libCEED binary (e.g. one built from source), LibCEED.jl can be configured using the JULIA_LIBCEED_LIB environment variable set to the absolute path of the libCEED dynamic library. For the configuration to take effect, LibCEED.jl must be built with this environment variable, for example:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"% JULIA_LIBCEED_LIB=/path/to/libceed.so julia\njulia> # press ] to enter package manager\n(env) pkg> build LibCEED","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"or, equivalently,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> withenv(\"JULIA_LIBCEED_LIB\" => \"/path/to/libceed.so\") do\n    Pkg.build(\"LibCEED\")\nend","category":"page"},{"location":"index.html#Features-of-the-high-level-interface-for-libCEED","page":"Home","title":"Features of the high-level interface for libCEED","text":"","category":"section"},{"location":"index.html#User-Q-functions","page":"Home","title":"User Q-functions","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"With LibCEED.jl, it is much easier to write dimension-independent user-defined Q-functions that automatically work on the GPU. See the related documentation for more information.","category":"page"},{"location":"index.html#Safe-access-to-CeedVector-objects","page":"Home","title":"Safe access to CeedVector objects","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"When accessing CeedVector objects, the C interface requires the user to manually call CeedVectorGetArray, paired with CeedVectorRestoreArray. If the user wants read-only access, then the user must call CeedVectorGetArrayRead, paired with CeedVectorRestoreArrayRead. This can possibly be bug-prone, because the user may forget to restore the array, or may match the Read version to get the array with non-Read version to restore the array (or vice versa).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In LibCEED.jl, this difficulty is mitigated using the witharray function and @witharray macro. There are also read-only versions, witharray_read and @witharray_read. When using this functionality, it is impossible to forget to restore the array, and the correct version is always paired properly.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For example, in ex1-volume, the following C code","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"// Compute and print the sum of the entries of 'v' giving the mesh volume.\nconst CeedScalar *v_host;\nCeedVectorGetArrayRead(v, CEED_MEM_HOST, &v_host);\nCeedScalar vol = 0.;\nfor (CeedInt i = 0; i < sol_size; i++) {\n  vol += v_host[i];\n}\nCeedVectorRestoreArrayRead(v, &v_host);","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"is replaced with the following equivalent Julia code","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# Compute and print the sum of the entries of 'v' giving the mesh volume.\nvol = witharray_read(sum, v, MEM_HOST)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In ex2-surface, the following C code","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"// Initialize 'u' with sum of coordinates, x+y+z.\nCeedScalar *u_host;\nconst CeedScalar *x_host;\nCeedVectorGetArray(u, CEED_MEM_HOST, &u_host);\nCeedVectorGetArrayRead(mesh_coords, CEED_MEM_HOST, &x_host);\nfor (CeedInt i = 0; i < sol_size; i++) {\n  u_host[i] = 0;\n  for (CeedInt d = 0; d < dim; d++)\n    u_host[i] += x_host[i+d*sol_size];\n}\nCeedVectorRestoreArray(u, &u_host);\nCeedVectorRestoreArrayRead(mesh_coords, &x_host);","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"is replaced with the following equivalent Julia code","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@witharray_read(x_host=mesh_coords, size=(mesh_size÷dim, dim),\n    @witharray(u_host=u, size=(sol_size,1),\n        sum!(u_host, x_host)))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The macro version can provide better performance if a closure is required, and allow for convenient reshaping of the vector into equivalently sized matrices or tensors.","category":"page"},{"location":"index.html#Ceed-objects","page":"Home","title":"Ceed objects","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n   \"Ceed.md\",\n   \"CeedVector.md\",\n   \"ElemRestriction.md\",\n   \"Basis.md\",\n   \"QFunction.md\",\n   \"Operator.md\",\n]","category":"page"},{"location":"index.html#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n   \"Misc.md\",\n   \"Globals.md\",\n   \"Quadrature.md\",\n]","category":"page"},{"location":"index.html#C-interface","page":"Home","title":"C interface","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"C.md\"]","category":"page"},{"location":"C.html#Low-level-C-interface","page":"Low-level C interface","title":"Low-level C interface","text":"","category":"section"},{"location":"C.html","page":"Low-level C interface","title":"Low-level C interface","text":"The low-level interface (provided in the LibCEED.C module) is in one-to-one correspondence with the C libCEED iterface, and is automatically generated (with some minor manual modifications) using the Julia package Clang.jl. The code used to generate bindings is available in generate_bindings.jl.","category":"page"},{"location":"C.html","page":"Low-level C interface","title":"Low-level C interface","text":"With the low-level interface, the user is responsible for freeing all allocated memory (calling the appropriate Ceed*Destroy functions). This interface is not type-safe, and calling functions with the wrong arguments can cause libCEED to crash.","category":"page"},{"location":"C.html","page":"Low-level C interface","title":"Low-level C interface","text":"It is generally recommended for users to use the Julia interface exported from the LibCEED module, unless other specific low-level functionality is required.","category":"page"}]
}
